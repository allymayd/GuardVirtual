package javaopencv;

import java.awt.BorderLayout; // Import for layout management
import java.awt.image.BufferedImage; // Import for handling image data
import java.io.ByteArrayInputStream; // Import for byte array input stream
import java.io.File; // Import for file handling
import java.io.InputStream; // Import for input stream
import java.nio.file.Paths; // Import for file path handling
import java.text.SimpleDateFormat; // Import for date formatting
import java.util.ArrayList; // Import for ArrayList
import java.util.Date; // Import for date handling
import java.util.Iterator; // Import for Iterator
import java.util.List; // Import for List
import javax.imageio.ImageIO; // Import for image IO
import javax.swing.ImageIcon; // Import for image icons
import javax.swing.JOptionPane; // Import for dialog boxes
import javax.swing.JDialog; // Import for dialog boxes
import javax.swing.SwingWorker; // Import for background worker
import org.opencv.core.Core; // Import for core OpenCV functionalities
import org.opencv.core.CvType; // Import for OpenCV types
import org.opencv.core.Mat; // Import for matrix operations
import org.opencv.core.MatOfByte; // Import for matrix of bytes
import org.opencv.core.MatOfPoint; // Import for matrix of points
import org.opencv.core.Point; // Import for point
import org.opencv.core.Rect; // Import for rectangle
import org.opencv.core.Scalar; // Import for scalar values
import org.opencv.core.Size; // Import for size
import org.opencv.highgui.Highgui; // Import for high-level GUI functionalities (deprecated in later versions)
import org.opencv.highgui.VideoCapture; // Import for video capture
import org.opencv.imgproc.Imgproc; // Import for image processing
import org.opencv.video.BackgroundSubtractorMOG; // Import for background subtraction

public class MainFrame extends javax.swing.JFrame {
    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME); // Load OpenCV native library
    }

    private Boolean begin = false; // Flag to indicate if video capture has started
    private Boolean firstFrame = true; // Flag to indicate if it's the first frame
    private VideoCapture video = null; // VideoCapture object to handle video input
    private CaptureThread thread = null; // Thread for capturing video
    private MatOfByte matOfByte = new MatOfByte(); // Matrix of bytes to hold image data
    private BufferedImage bufImage = null; // BufferedImage to hold the frame image
    private InputStream in; // InputStream to read image data
    private Mat frameaux = new Mat(); // Auxiliary frame for processing
    private Mat frame = new Mat(240, 320, CvType.CV_8UC3); // Main frame with dimensions 240x320 and type CV_8UC3
    private Mat lastFrame = new Mat(240, 320, CvType.CV_8UC3); // Last captured frame
    private Mat currentFrame = new Mat(240, 320, CvType.CV_8UC3); // Current frame
    private Mat processedFrame = new Mat(240, 320, CvType.CV_8UC3); // Processed frame
    private ImagePanel image; // Panel to display images
    private BackgroundSubtractorMOG bsMOG = new BackgroundSubtractorMOG(); // Background subtractor
    private int savedelay = 0; // Delay for saving frames
    String currentDir = ""; // Current directory
    String detectionsDir = "detections"; // Directory for saving detections

    public MainFrame() {
        initComponents(); // Initialize components (generated by IDE GUI designer)
        image = new ImagePanel(new ImageIcon("figs/320x240.gif").getImage()); // Initialize image panel with a placeholder image
        jPanelSource1.add(image, BorderLayout.CENTER); // Add image panel to the GUI

        currentDir = Paths.get(".").toAbsolutePath().normalize().toString(); // Get the current directory
        detectionsDir = currentDir + File.separator + detectionsDir; // Set the detections directory path
        jTextFieldSaveLocation.setText(detectionsDir); // Display detections directory in the text field
    }

    private void start() {
        if (!begin) { // If video capture hasn't started
            int sourcen = Integer.parseInt(jTextFieldSource1.getText()); // Get video source number from text field
            System.out.println("Opening source: " + sourcen); // Print the source number

            video = new VideoCapture(sourcen); // Initialize VideoCapture with the source

            if (video.isOpened()) { // If the video source is opened successfully
                thread = new CaptureThread(); // Create a new capture thread
                thread.start(); // Start the capture thread
                begin = true; // Set the begin flag to true
                firstFrame = true; // Set the firstFrame flag to true
            } else {
                showErrorMessage("Please Try Again.", "Wrong Video Source."); // Show error message if the video source is wrong
            }
        }
    }

    private void stop() {
        if (begin) { // If video capture has started
            try {
                Thread.sleep(500); // Sleep for 500 milliseconds
            } catch (Exception ex) {
                ex.printStackTrace(); // Print stack trace in case of an exception
            }
            video.release(); // Release the video capture resource
            begin = false; // Set the begin flag to false
        }
    }

    private void showErrorMessage(String message, String title) {
        JOptionPane error = new JOptionPane(message, JOptionPane.WARNING_MESSAGE); // Create a warning message dialog
        final JDialog dlg = error.createDialog(title); // Create a dialog with the given title
        dlg.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); // Prevent dialog from being closed manually

        SwingWorker<Void, Void> worker = new SwingWorker<Void, Void>() {
            @Override
            protected Void doInBackground() throws Exception {
                Thread.sleep(1500); // Sleep for 1.5 seconds
                return null;
            }

            @Override
            protected void done() {
                dlg.setVisible(false); // Hide the dialog after the sleep
            }
        };

        worker.execute(); // Execute the SwingWorker in a separate thread
        dlg.setVisible(true); // Show the dialog
    }

    public static String getCurrentTimeStamp() {
        SimpleDateFormat sdfDate = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss"); // Date format
        Date now = new Date(); // Get current date
        return sdfDate.format(now); // Return formatted date as string
    }

    public ArrayList<Rect> detection_contours(Mat frame, Mat outmat) {
        Mat v = new Mat(); // Temporary matrix for contours
        Mat vv = outmat.clone(); // Clone the output matrix
        List<MatOfPoint> contours = new ArrayList<>(); // List to hold contours
        Imgproc.findContours(vv, contours, v, Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE); // Find contours in the image

        double maxArea = 100; // Minimum area for a contour to be considered
        ArrayList<Rect> rect_array = new ArrayList<>(); // List to hold bounding rectangles

        for (int idx = 0; idx < contours.size(); idx++) { // Iterate through each contour
            Mat contour = contours.get(idx); // Get the current contour
            double contourarea = Imgproc.contourArea(contour); // Calculate the area of the contour
            if (contourarea > maxArea) { // If the contour area is greater than the minimum area
                Rect r = Imgproc.boundingRect(contours.get(idx)); // Get the bounding rectangle for the contour
                rect_array.add(r); // Add the rectangle to the list
                Imgproc.drawContours(frame, contours, idx, new Scalar(0, 0, 255)); // Draw the contour on the frame
            }
        }

        v.release(); // Release the temporary matrix
        return rect_array; // Return the list of bounding rectangles
    }

 
  class CaptureThread extends Thread {
    @Override
    public void run() {
        // Check if the video stream is opened
        if (video.isOpened()) {
            // Loop while the begin flag is true
            while (begin) {
                // Retrieve the current frame from the video stream
                video.retrieve(frameaux);
                // Resize the retrieved frame to match the target frame size
                Imgproc.resize(frameaux, frame, frame.size());
                // Copy the resized frame to the currentFrame
                frame.copyTo(currentFrame);

                // If this is the first frame
                if (firstFrame) {
                    // Copy the current frame to the lastFrame
                    frame.copyTo(lastFrame);
                    // Set firstFrame to false
                    firstFrame = false;
                    continue; // Skip the rest of the loop
                }

                // If motion detection checkbox is selected
                if (jCheckBoxMotionDetection.isSelected()) {
                    // Apply Gaussian blur to the current frame
                    Imgproc.GaussianBlur(currentFrame, currentFrame, new Size(3, 3), 0);
                    // Apply Gaussian blur to the last frame
                    Imgproc.GaussianBlur(lastFrame, lastFrame, new Size(3, 3), 0);

                    // Subtract the last frame from the current frame to get the difference
                    Core.subtract(currentFrame, lastFrame, processedFrame);

                    // Convert the difference image to grayscale
                    Imgproc.cvtColor(processedFrame, processedFrame, Imgproc.COLOR_RGB2GRAY);

                    // Get the threshold value from the slider
                    int threshold = jSliderThreshold.getValue();
                    // Apply thresholding to the grayscale image
                    Imgproc.threshold(processedFrame, processedFrame, threshold, 255, Imgproc.THRESH_BINARY);

                    // Detect contours in the processed frame
                    ArrayList<Rect> array = detection_contours(currentFrame, processedFrame);

                    // If any contours are detected
                    if (array.size() > 0) {
                        // Draw rectangles around each detected contour
                        for (Rect obj : array) {
                            Core.rectangle(currentFrame, obj.br(), obj.tl(), new Scalar(0, 255, 0), 1);
                        }
                    }

                    // If alarm checkbox is selected
                    if (jCheckBoxAlarm.isSelected()) {
                        // Get the sensibility value from the slider
                        double sensibility = jSliderSensibility.getValue();
                        // Count the number of non-zero pixels in the processed frame
                        double nonZeroPixels = Core.countNonZero(processedFrame);

                        // Calculate the total number of pixels in the frame
                        double nrows = processedFrame.rows();
                        double ncols = processedFrame.cols();
                        double total = nrows * ncols / 10;

                        // Calculate the percentage of detected pixels
                        double detections = (nonZeroPixels / total) * 100;

                        // If the detections exceed the sensibility threshold
                        if (detections >= sensibility) {
                            // Show a dialog to the user asking if they want to continue
                            int result = JOptionPane.showConfirmDialog(
                                null,
                                "Motion detected! Someone is outside the door!",
                                "Motion Detected",
                                JOptionPane.OK_CANCEL_OPTION
                            );

                            // If the user does not click "OK"
                            if (result != JOptionPane.OK_OPTION) {
                                // Deselect the motion detection checkbox and exit the loop
                                jCheckBoxMotionDetection.setSelected(false);
                                break;
                            }

                            // Start a countdown thread
                            Thread countdownThread = new Thread(() -> {
                                for (int i = 3; i >= 0; i--) {
                                    try {
                                        Thread.sleep(600); // Sleep for 600 milliseconds (0.6 seconds)
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                    System.out.println("Countdown: " + i);
                                }
                            });
                            countdownThread.start();

                            // Wait for the countdown thread to finish
                            try {
                                countdownThread.join();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }

                            // Display "MOTION DETECTED" text on the current frame
                            Core.putText(currentFrame, "MOTION DETECTED",
                                new Point(5, currentFrame.cols() / 2),
                                Core.FONT_HERSHEY_TRIPLEX, 1.0, new Scalar(0, 0, 255));

                            // If save checkbox is selected
                            if (jCheckBoxSave.isSelected()) {
                                if (savedelay == 2) {
                                    // Save the processed frame as an image file
                                    String filename = jTextFieldSaveLocation.getText() + File.separator + "capture_" + getCurrentTimeStamp() + ".jpg";
                                    System.out.println("Saving results in: " + filename);
                                    Highgui.imwrite(filename, processedFrame);
                                    savedelay = 0; // Reset the save delay
                                } else {
                                    savedelay++; // Increment the save delay
                                }
                            }
                        } else {
                            savedelay = 0; // Reset the save delay if detections are below the threshold
                            System.out.println("");
                        }
                    }
                    // Copy the current frame to the processed frame for further processing
                    currentFrame.copyTo(processedFrame);
                }

                // Encode the processed frame as a JPEG image
                Highgui.imencode(".jpg", processedFrame, matOfByte);
                // Convert the encoded image to a byte array
                byte[] byteArray = matOfByte.toArray();

                try {
                    // Create an input stream from the byte array
                    in = new ByteArrayInputStream(byteArray);
                    // Read the image from the input stream
                    bufImage = ImageIO.read(in);
                } catch (Exception ex) {
                    ex.printStackTrace();
                }

                // Update the displayed image with the buffered image
                image.updateImage(bufImage);
                // Copy the current frame to the last frame for the next iteration
                frame.copyTo(lastFrame);

                try {
                    Thread.sleep(1); // Sleep for 1 millisecond
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
    }
}

  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelSource1 = new javax.swing.JPanel();
        jLabelSource1 = new javax.swing.JLabel();
        jTextFieldSource1 = new javax.swing.JTextField();
        jButtonStart = new javax.swing.JButton();
        jButtonStop = new javax.swing.JButton();
        jCheckBoxMotionDetection = new javax.swing.JCheckBox();
        jSliderThreshold = new javax.swing.JSlider();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jCheckBoxAlarm = new javax.swing.JCheckBox();
        jLabel3 = new javax.swing.JLabel();
        jSliderSensibility = new javax.swing.JSlider();
        jTextFieldSaveLocation = new javax.swing.JTextField();
        jCheckBoxSave = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Java OpenCV Webcam");
        setBackground(new java.awt.Color(106, 74, 58));

        jPanelSource1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        javax.swing.GroupLayout jPanelSource1Layout = new javax.swing.GroupLayout(jPanelSource1);
        jPanelSource1.setLayout(jPanelSource1Layout);
        jPanelSource1Layout.setHorizontalGroup(
            jPanelSource1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 317, Short.MAX_VALUE)
        );
        jPanelSource1Layout.setVerticalGroup(
            jPanelSource1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 238, Short.MAX_VALUE)
        );

        jLabelSource1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelSource1.setText("Source:");

        jTextFieldSource1.setText("0");

        jButtonStart.setText("Start");
        jButtonStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonStartActionPerformed(evt);
            }
        });

        jButtonStop.setText("Pause");
        jButtonStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonStopActionPerformed(evt);
            }
        });

        jCheckBoxMotionDetection.setText("Motion Detection");

        jSliderThreshold.setMaximum(255);
        jSliderThreshold.setPaintLabels(true);
        jSliderThreshold.setPaintTicks(true);
        jSliderThreshold.setValue(15);

        jLabel1.setText("Threshold:");

        jCheckBoxAlarm.setText("Alarm");

        jLabel3.setText("Sensibility:");

        jSliderSensibility.setMinimum(1);
        jSliderSensibility.setPaintLabels(true);
        jSliderSensibility.setPaintTicks(true);
        jSliderSensibility.setValue(10);

        jCheckBoxSave.setText("Save detections in:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(8, 8, ðŸ˜Ž
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabelSource1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldSource1, javax.swing.GroupLayout.PREFERRED_SIZE, 138, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jButtonStart, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(162, 162, 162)
                                .addComponent(jButtonStop, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jCheckBoxMotionDetection)
                                            .addGap(18, 18, 18)
                                            .addComponent(jLabel1))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jCheckBoxAlarm)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jLabel3)))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jSliderThreshold, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                                        .addComponent(jSliderSensibility, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jCheckBoxSave)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jTextFieldSaveLocation, javax.swing.GroupLayout.PREFERRED_SIZE, 195, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addComponent(jPanelSource1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 14, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelSource1)
                    .addComponent(jTextFieldSource1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelSource1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jSliderThreshold, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jCheckBoxMotionDetection)
                        .addComponent(jLabel1)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSliderSensibility, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 12, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextFieldSaveLocation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jCheckBoxSave))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButtonStop)
                            .addComponent(jButtonStart)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jCheckBoxAlarm)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonStartActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jButtonStartActionPerformed
    {//GEN-HEADEREND:event_jButtonStartActionPerformed
      start();
    }//GEN-LAST:event_jButtonStartActionPerformed

    private void jButtonStopActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jButtonStopActionPerformed
    {//GEN-HEADEREND:event_jButtonStopActionPerformed
      stop();
    }//GEN-LAST:event_jButtonStopActionPerformed

public static void main(String args[]) {
    // Main method, entry point of the Java application
    try {
        // Try to set the Nimbus look and feel
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            // Loop through installed look-and-feel options
            if ("Nimbus".equals(info.getName())) {
                // If Nimbus look and feel is available
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                // Set the look and feel to Nimbus
                break;
                // Exit the loop once Nimbus is set
            }
        }
        
    } catch (ClassNotFoundException ex) {
        // Handle exception if Nimbus look and feel class is not found
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        // Handle exception if Nimbus look and feel cannot be instantiated
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        // Handle exception if there is illegal access to Nimbus look and feel
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        // Handle exception if Nimbus look and feel is unsupported
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }

    // Set the Nimbus look and feel (second attempt if first one fails)

    try {
        // Try to set the Windows look and feel
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            // Loop through installed look-and-feel options
            if ("Windows".equals(info.getName())) {
                // If Windows look and feel is available
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                // Set the look and feel to Windows
                break;
                // Exit the loop once Windows is set
            }
        }
    } catch (ClassNotFoundException ex) {
        // Handle exception if Windows look and feel class is not found
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        // Handle exception if Windows look and feel cannot be instantiated
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        // Handle exception if there is illegal access to Windows look and feel
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        // Handle exception if Windows look and feel is unsupported
        java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    //</editor-fold>

     // Create and display the application window on the Event Dispatch Thread
    java.awt.EventQueue.invokeLater(new Runnable() {
        public void run() {
            new MainFrame().setVisible(true);
            // Make the MainFrame (main application window) visible
        }
    });
}

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonStart;
    private javax.swing.JButton jButtonStop;
    private javax.swing.JCheckBox jCheckBoxAlarm;
    private javax.swing.JCheckBox jCheckBoxMotionDetection;
    private javax.swing.JCheckBox jCheckBoxSave;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabelSource1;
    private javax.swing.JPanel jPanelSource1;
    private javax.swing.JSlider jSliderSensibility;
    private javax.swing.JSlider jSliderThreshold;
    private javax.swing.JTextField jTextFieldSaveLocation;
    private javax.swing.JTextField jTextFieldSource1;
    // End of variables declaration//GEN-END:variables
}